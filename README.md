0.1.1. Обзор проекта и бизнес-цели
Этот документ представляет собой всесторонний и углубленный анализ проекта RPG-Store, который сочетает в себе e-commerce и игровые элементы RPG, создавая для WooCommerce (на базе дочерней темы Woodmart Child с визуальным оформлением в стиле "Megamarket 2" и плагина custom-rewards-plugin) динамичную платформу лояльности.
Взаимодействие пользователей с сайтом как с игрой:
Регистрация: С выбором расы (Human, Elf, Orc, Dwarf) и пола.
Накопление опыта (XP): За покупки и игровые действия, что ведет к повышению уровня.
Виртуальная валюта «золото» (crp_gold): Выдается за траты и задания, используется в Магазине промокодов.
Сбор купонов:
RPG-купоны: Общие и расовые, получаемые за активность или достижения, хранятся в личном RPG-инвентаре.
Купоны Продавцов (Dokan): Пользователи могут "взять" купоны со страниц магазинов продавцов или добавить их по коду в отдельный инвентарь купонов продавцов.
Покупка промокодов: На эксклюзивные игровые ключи (функционал магазина промокодов).
Цель проекта: Предоставить исчерпывающее понимание текущей архитектуры системы, ее функциональных возможностей, детального взаимодействия между различными компонентами, а также оценить степень соответствия разработанного функционала техническому заданию (ТЗ).
Техническое задание (версия 1.5 от 20.05.2025) определяет ключевые цели и требования:
Геймификация пользовательского опыта:
Система Рас (Человек, Эльф, Орк, Гном).
Система Уровней и Опыта (XP).
Виртуальная Валюта ("Золото").
Система Достижений (Achievements).
Система Заданий (Tasks).
Рефакторинг плагина custom-rewards-plugin: Перевод на ООП.
Тесная интеграция плагина с дочерней темой woodmart-child.
Административный интерфейс плагина: Управление через CPT (crp_achievement, crp_task), мета-боксы, WP_List_Table.
Пользовательский интерфейс плагина (Frontend): Отображение информации в личном кабинете, уведомления. Пользовательский интерфейс должен соответствовать теме "Megamarket 2" – быть чистым, современным и интуитивно понятным.
Система Триггеров, Условий и Наград плагина.
Архитектурные требования к плагину: ООП, пространства имен, PSR-4, WordPress Coding Standards. (Локализация i18n/l10n была удалена из требований к плагину).
Бизнес-цели и KPI: (Таблица KPI остается без изменений)
|
| Цель | Метрика / KPI |
| Рост LTV | +25 % через механики геймификации |
| Увеличение среднего чека | +15 % за счёт купонов и золота |
| Удержание пользователей | Retention rate, частота возвращений |
| Партнёрские активности | Количество промо‑акций с игровыми студиями |
| Техническая устойчивость | Время на onboarding новых dev, баги/релиз |
Этот документ содержит детальный анализ структуры и функциональности вашего WordPress проекта, построенного на базе дочерней темы WoodMart с кастомной RPG-системой и интеграциями.
1. Общий обзор проекта
Проект представляет собой дочернюю тему для популярной темы WoodMart для WordPress. Основная цель проекта – расширить стандартные возможности электронной коммерции (WooCommerce) и многопользовательской торговой площадки (Dokan) путем добавления RPG-элементов. Это включает в себя создание персонажей, систему рас, уровней, а также кастомные скидки и возможно, другие игровые механики, интегрированные в процесс покупки и взаимодействия с сайтом.
Ключевые компоненты:
Дочерняя тема WoodMart: Основа для кастомизации.
RPG-система: Управление персонажами, расами, уровнями.
Интеграция с WooCommerce: Расширение функционала магазина, возможно, с привязкой к RPG-элементам.
Интеграция с Dokan: Расширение функционала для продавцов на маркетплейсе, возможно, с кастомными купонами или другими RPG-связанными функциями.
Кастомные шорткоды: Для вывода специфического контента (например, формы регистрации, выбора гендера).
AJAX обработчики: Для динамического взаимодействия без перезагрузки страницы.
Кастомизация админ-панели: Для управления RPG-данными пользователей.
2. Структура директорий
Файлы проекта организованы следующим образом:
woodmart-child/
├── assets/
│   ├── css/
│   │   └── login-register.css       # Стили для форм логина/регистрации
│   └── js/
│       ├── login-register.js        # JS для форм логина/регистрации
│       ├── rpg-account.js           # JS для страницы персонажа в "Мой аккаунт"
│       ├── rpg-admin-profile.js     # JS для RPG-элементов в профиле пользователя (админка)
│       └── rpg-cart.js              # JS для RPG-элементов на странице корзины
├── dokan/
│   └── coupon/
│       └── store.php                # Шаблон для управления купонами продавца Dokan
├── includes/
│   ├── Admin/
│   │   ├── AdminAJAXHandler.php     # AJAX-обработчик для админ-панели
│   │   ├── UserProfile.php          # Кастомизация профиля пользователя в админке
│   │   └── UserTable.php            # Кастомизация таблицы пользователей в админке
│   ├── Assets/
│   │   └── AssetManager.php         # Управление подключением CSS и JS файлов
│   ├── Core/
│   │   ├── AJAXHandler.php          # Основной AJAX-обработчик для фронтенда
│   │   ├── Installer.php            # Логика установки (активации) темы
│   │   ├── Loader.php               # Загрузчик основных компонентов темы
│   │   ├── Theme.php                # Основной класс темы, хуки и фильтры
│   │   └── Utils.php                # Вспомогательные функции
│   ├── Integration/
│   │   └── dokan/
│   │       ├── DokanAJAXHandler.php # AJAX-обработчик для интеграции с Dokan
│   │       ├── DokanIntegrationManager.php # Менеджер интеграции с Dokan
│   │       └── DokanUserCouponDB.php  # Работа с БД для купонов пользователей Dokan
│   ├── Pages/
│   │   └── CharacterPage.php        # Логика для страницы персонажа
│   ├── RPG/
│   │   ├── Character.php            # Класс "Персонаж"
│   │   ├── LevelManager.php         # Менеджер уровней и опыта персонажа
│   │   ├── Race.php                 # Абстрактный класс/интерфейс для рас
│   │   ├── RaceFactory.php          # Фабрика для создания объектов рас
│   │   └── Races/                   # Конкретные реализации рас
│   │       ├── Dwarf.php
│   │       ├── Elf.php
│   │       ├── Human.php
│   │       └── Orc.php
│   ├── Shortcodes/
│   │   ├── GenderSelectShortcode.php # Шорткод для выбора гендера
│   │   └── RegisterFormShortcode.php # Шорткод для кастомной формы регистрации
│   ├── WooCommerce/
│   │   ├── DiscountManager.php      # Менеджер кастомных скидок
│   │   └── WooCommerceIntegration.php # Менеджер интеграции с WooCommerce
│   └── autoload.php                 # Файл для автозагрузки классов (PSR-4)
├── templates/
│   └── myaccount/
│       └── character-page-content.php # Шаблон для отображения контента страницы персонажа
├── functions.php                    # Основной файл дочерней темы
├── index.php                        # Стандартный шаблон WordPress
└── style.css                        # Файл стилей дочерней темы (с информацией о теме)


3. Ядро системы (Инициализация, Автозагрузка, Настройка темы)
3.1. functions.php (woodmart-child/functions.php)
Назначение: Это главный файл дочерней темы WordPress. Он загружается сразу после functions.php родительской темы.
Основные задачи:
Определение констант темы (пути, версии и т.д.).
Подключение файла автозагрузки классов (includes/autoload.php).
Инициализация основного класса темы (вероятно, Includes\Core\Theme).
Подключение стилей и скриптов.
Регистрация хуков (actions и filters) WordPress для добавления или изменения функциональности.
Может содержать небольшие вспомогательные функции или подключения других файлов с логикой.
3.2. includes/autoload.php
Назначение: Реализует автозагрузку классов по стандарту PSR-4. Это позволяет автоматически подключать файлы классов при их первом использовании, без необходимости писать require_once для каждого класса.
Принцип работы: Регистрирует функцию (обычно через spl_autoload_register), которая преобразует имя класса с его пространством имен в путь к файлу. Например, класс Includes\RPG\Character будет искаться в файле woodmart-child/includes/RPG/Character.php.
Важность: Упрощает управление зависимостями и структурирование кода.
3.3. includes/Core/Loader.php
Назначение: Вероятно, этот класс отвечает за инициализацию и загрузку различных модулей и компонентов темы.
Возможные задачи:
Создание экземпляров ключевых классов (менеджеров, обработчиков).
Регистрация шорткодов.
Подключение обработчиков AJAX-запросов.
Вызов методов инициализации у других модулей.
Взаимодействие: Скорее всего, экземпляр Loader создается и запускается из Theme.php или напрямую из functions.php.
3.4. includes/Core/Theme.php
Назначение: Основной управляющий класс темы. Часто реализует паттерн Singleton, чтобы гарантировать единственный экземпляр.
Основные задачи:
Хранение основной конфигурации темы.
Инициализация Loader.php для загрузки компонентов.
Регистрация основных хуков WordPress (например, after_setup_theme, wp_enqueue_scripts, init).
Управление жизненным циклом темы.
Пример (псевдокод):
namespace Includes\Core;
class Theme {
    private static $instance;
    private $loader;
    private function __construct() {
        $this->define_constants();
        $this->load_dependencies(); // Загрузка autoload.php
        $this->loader = new Loader();
        $this->setup_hooks();
    }
    public static function get_instance() {
        if (null === self::$instance) {
            self::$instance = new self();
        }
        return self::$instance;
    }
    private function setup_hooks() {
        // Добавление хуков через $this->loader или напрямую
        add_action('init', [$this, 'initialize_components']);
        // ... другие хуки
    }
    public function initialize_components() {
        // Инициализация различных частей темы
        // new Includes\RPG\Character();
        // new Includes\WooCommerce\WooCommerceIntegration();
        // и т.д.
    }
}


3.5. includes/Core/Installer.php
Назначение: Выполняет задачи, необходимые при активации темы.
Возможные задачи:
Создание кастомных таблиц в базе данных (например, для хранения RPG-данных, если они не хранятся в мета-полях пользователей или постах).
Установка начальных опций темы в wp_options.
Проверка наличия необходимых плагинов (например, WooCommerce, Dokan).
Создание необходимых страниц (например, страница персонажа).
Хуки: Обычно привязывается к хуку register_activation_hook для файла плагина, но в случае темы это может быть реализовано через проверку опции, которая устанавливается при первой активации.
3.6. includes/Core/AJAXHandler.php
Назначение: Обрабатывает общие AJAX-запросы, не связанные с админ-панелью или специфическими плагинами вроде Dokan.
Принцип работы:
Регистрирует AJAX-действия WordPress (wp_ajax_your_action для авторизованных пользователей и wp_ajax_nopriv_your_action для неавторизованных).
Содержит методы, которые выполняют определенную логику в ответ на AJAX-запросы от JavaScript на фронтенде.
Возвращает данные в формате JSON (обычно с помощью wp_send_json_success() или wp_send_json_error()).
3.7. includes/Core/Utils.php
Назначение: Содержит набор статических вспомогательных функций, которые могут использоваться в различных частях темы.
Примеры функций:
Форматирование данных.
Генерация HTML-элементов.
Проверки условий.
Работа с массивами или строками.
Преимущество: Избегает дублирования кода и делает его более чистым.
3.8. includes/Assets/AssetManager.php
Назначение: Централизованное управление подключением CSS-стилей и JavaScript-файлов. (Более подробно будет рассмотрено в разделе 9).
Основные задачи:
Регистрация скриптов и стилей (wp_register_script, wp_register_style).
Подключение скриптов и стилей на нужных страницах (wp_enqueue_script, wp_enqueue_style).
Передача данных из PHP в JavaScript с помощью wp_localize_script. Это часто используется для передачи AJAX URL, nonces, переводов и других настроек.
Хуки: Обычно использует хук wp_enqueue_scripts для фронтенда и admin_enqueue_scripts для админ-панели.
4. RPG Система
Этот модуль отвечает за всю игровую логику, связанную с персонажами, их развитием, расами и атрибутами.
4.1. includes/RPG/Character.php
Назначение: Представляет сущность "Персонаж" в системе. Этот класс, скорее всего, инкапсулирует все данные и логику, связанные с конкретным персонажем пользователя.
Вероятные свойства:
user_id: ID пользователя WordPress, к которому привязан персонаж.
name: Имя персонажа.
race: Объект или идентификатор расы персонажа (например, экземпляр класса Includes\RPG\Races\Human).
gender: Пол персонажа.
level: Текущий уровень персонажа.
experience_points (XP): Текущее количество очков опыта.
attributes: Массив или объект с атрибутами персонажа (сила, ловкость, интеллект и т.д.). Конкретные атрибуты могут зависеть от расы или класса (если классы есть).
inventory: Возможно, массив для хранения предметов инвентаря.
date_created: Дата создания персонажа.
Вероятные методы:
__construct(int $user_id): Конструктор, загружающий данные персонажа по ID пользователя.
load_character_data(): Метод для загрузки данных персонажа из базы данных (вероятно, из мета-полей пользователя wp_usermeta).
save_character_data(): Метод для сохранения данных персонажа в базу данных.
get_name(), set_name(string $name): Геттеры и сеттеры для свойств.
get_race(), set_race(Race $race): Геттеры и сеттеры для расы.
add_experience(int $amount): Метод для добавления очков опыта. Вероятно, вызывает LevelManager для проверки повышения уровня.
level_up(): Метод для повышения уровня персонажа.
get_attribute(string $attribute_name): Получение значения атрибута.
set_attribute(string $attribute_name, $value): Установка значения атрибута.
has_character(): Проверяет, создан ли персонаж для данного пользователя.
Хранение данных: Наиболее вероятно, что данные персонажа (раса, уровень, опыт, атрибуты) хранятся в мета-полях пользователя (wp_usermeta) с префиксами, например, rpg_character_race, rpg_character_level и т.д. Менее вероятно, но возможно, использование отдельной таблицы в БД, если структура данных сложная.
4.2. includes/RPG/Race.php
Назначение: Вероятно, это абстрактный класс или интерфейс, который определяет общую структуру и поведение для всех рас в игре.
Если это абстрактный класс, он может содержать:
name: Название расы (например, "Человек", "Эльф").
description: Описание расы.
base_attributes: Массив с базовыми стартовыми атрибутами для этой расы.
attribute_modifiers: Модификаторы атрибутов, характерные для расы (например, +1 к силе для орков).
abilities: Массив с уникальными способностями или перками расы.
get_name(): Метод для получения названия расы.
get_description(): Метод для получения описания.
get_base_attributes(): Метод для получения базовых атрибутов.
apply_racial_modifiers(Character $character): Абстрактный или конкретный метод для применения расовых модификаторов к персонажу.
Если это интерфейс, он будет определять контракт:
interface Race {
    public function getName(): string;
    public function getDescription(): string;
    public function getBaseAttributes(): array;
    public function applyRacialModifiers(Character $character): void;
}


Цель: Обеспечить единообразие и полиморфизм при работе с различными расами.
4.3. includes/RPG/Races/ (Dwarf.php, Elf.php, Human.php, Orc.php)
Назначение: Конкретные реализации рас, наследующие от абстрактного класса Race или реализующие интерфейс Race.
Пример (для Dwarf.php):
namespace Includes\RPG\Races;
use Includes\RPG\Race; // Предполагается, что это интерфейс или абстрактный класс
use Includes\RPG\Character;

class Dwarf extends Race { // или class Dwarf implements Race
    public function __construct() {
        $this->name = 'Дворф'; // Или загрузка из настроек/БД
        $this->description = 'Крепкие и выносливые жители гор...';
        $this->base_attributes = ['strength' => 12, 'dexterity' => 8, /* ... */];
        $this->attribute_modifiers = ['constitution' => +2, 'charisma' => -1];
    }

    public function apply_racial_modifiers(Character $character) {
        // Логика применения специфичных для дворфов бонусов
        // Например, увеличение здоровья или сопротивления ядам
        // parent::apply_racial_modifiers($character); // Если есть общая логика в базовом классе
        $character->set_attribute('constitution', $character->get_attribute('constitution') + 2);
    }

    public function get_special_ability_description(): string {
        return "Сопротивление ядам: Дворфы получают бонус к спасброскам против ядов.";
    }
    // Реализация других методов интерфейса/абстрактного класса, если необходимо
    public function getName(): string { return $this->name; }
    public function getDescription(): string { return $this->description; }
    public function getBaseAttributes(): array { return $this->base_attributes; }
}


Каждый файл расы будет определять:
Уникальные значения для имени, описания, базовых атрибутов.
Специфичные расовые модификаторы и способности.
Реализацию метода apply_racial_modifiers, если он абстрактный.
4.4. includes/RPG/RaceFactory.php
Назначение: Реализует паттерн "Фабричный метод" или "Абстрактная фабрика" для создания объектов рас. Это позволяет создавать объекты рас, не раскрывая логику их создания и не привязываясь к конкретным классам рас напрямую в коде, где они используются.
Вероятные методы:
create_race(string $race_slug): ?Race: Статический или обычный метод, который принимает идентификатор расы (например, "human", "elf") и возвращает экземпляр соответствующего класса расы (new Human(), new Elf()) или null, если раса не найдена.
Пример использования:
// Где-то в коде при создании персонажа
$race_slug = get_user_meta($user_id, 'selected_race_slug', true);
$race_factory = new Includes\RPG\RaceFactory();
$character_race = $race_factory->create_race($race_slug);

if ($character_race) {
    $character->set_race($character_race);
    $character_race->apply_racial_modifiers($character);
}


Преимущества:
Гибкость: Легко добавлять новые расы, не изменяя код, который их использует.
Инкапсуляция: Логика создания объектов рас скрыта внутри фабрики.
4.5. includes/RPG/LevelManager.php
Назначение: Управляет системой уровней и опыта персонажей.
Вероятные свойства:
level_caps: Массив, определяющий количество опыта, необходимое для каждого уровня (например, [1 => 0, 2 => 1000, 3 => 2500, ...]).
max_level: Максимально возможный уровень.
Вероятные методы:
__construct(): Может загружать конфигурацию уровней (например, из опций темы или констант).
add_experience(Character $character, int $amount): Добавляет опыт персонажу. После добавления проверяет, не достиг ли персонаж нового уровня.
check_for_level_up(Character $character): Проверяет, достаточно ли у персонажа опыта для следующего уровня. Если да, вызывает level_up().
level_up(Character $character): Повышает уровень персонажа. Может включать:
Увеличение атрибутов (по определенным правилам или на выбор пользователя).
Предоставление новых способностей.
Отправку уведомления пользователю.
get_experience_for_level(int $level): Возвращает количество опыта, необходимое для достижения указанного уровня.
get_next_level_experience(int $current_level): Возвращает количество опыта, необходимое для следующего уровня.
calculate_attribute_increase(Character $character): Логика расчета повышения атрибутов при повышении уровня.
Взаимодействие:
Класс Character будет вызывать LevelManager при добавлении опыта.
LevelManager будет взаимодействовать с объектом Character для обновления его уровня и, возможно, атрибутов.
4.6. includes/Pages/CharacterPage.php
Назначение: Управляет логикой и отображением страницы персонажа. Эта страница обычно является частью раздела "Мой аккаунт" WooCommerce или отдельной страницей.
Основные задачи:
Добавление новой вкладки или эндпоинта в "Мой аккаунт" WooCommerce (например, с помощью фильтров woocommerce_account_menu_items и woocommerce_account_{endpoint}_endpoint).
Обработка запросов к этой странице.
Получение данных о персонаже текущего пользователя (Character object).
Передача данных персонажа в шаблон для отображения (character-page-content.php).
Возможно, обработка форм на этой странице (например, для смены имени персонажа, распределения очков атрибутов при повышении уровня).
Хуки:
init или wp_loaded: для регистрации эндпоинтов.
woocommerce_account_menu_items: для добавления пункта меню.
woocommerce_account_{your_endpoint}_endpoint: для вывода контента на странице эндпоинта.
template_redirect: для перехвата запроса и загрузки кастомного шаблона, если это не эндпоинт WooCommerce.
4.7. templates/myaccount/character-page-content.php
Назначение: PHP-шаблон для отображения информации о персонаже на фронтенде.
Содержимое:
HTML-разметка для вывода имени персонажа, расы, уровня, опыта, атрибутов, способностей и т.д.
PHP-код для доступа к переменным, переданным из CharacterPage.php (или напрямую из хука WooCommerce), и вывода данных объекта Character.
Может содержать формы для взаимодействия с персонажем (если это предусмотрено).
Пример:
<?php
/**
 * Character Page Content
 *
 * @var \Includes\RPG\Character $character // Предполагается, что объект персонажа передан в шаблон
 */

if ( ! defined( 'ABSPATH' ) ) {
    exit; // Exit if accessed directly.
}

if ( ! $character || ! $character->has_character() ) {
    echo '<p>Персонаж еще не создан.</p>';
    // Возможно, здесь будет шорткод для создания персонажа
    return;
}
?>
<h2>Профиль персонажа: <?php echo esc_html( $character->get_name() ); ?></h2>
<p><strong>Раса:</strong> <?php echo esc_html( $character->get_race()->get_name() ); ?></p>
<p><strong>Уровень:</strong> <?php echo esc_html( $character->get_level() ); ?></p>
<p><strong>Опыт:</strong> <?php echo esc_html( $character->get_experience_points() ); ?> / <?php /* Логика получения опыта для следующего уровня */ ?></p>

<h3>Атрибуты:</h3>
<ul>
    <li><strong>Сила:</strong> <?php echo esc_html( $character->get_attribute('strength') ); ?></li>
    <?php // Другие атрибуты ?>
</ul>
<?php // Другая информация: способности, инвентарь и т.д. ?>


4.8. JavaScript файлы (assets/js/rpg-account.js, assets/js/rpg-admin-profile.js)
assets/js/rpg-account.js:
Назначение: Управляет интерактивностью на странице персонажа в "Мой аккаунт".
Возможные функции:
AJAX-запросы для обновления данных персонажа без перезагрузки страницы (например, смена имени, если это разрешено).
Обработка выбора при повышении уровня (если есть выбор атрибутов или способностей).
Динамическое отображение информации.
assets/js/rpg-admin-profile.js:
Назначение: Добавляет интерактивность к RPG-полям на странице редактирования профиля пользователя в админ-панели WordPress.
Возможные функции:
AJAX-запросы для сохранения RPG-данных пользователя (например, изменение расы, уровня, опыта администратором).
Валидация вводимых данных.
Динамическое обновление полей в зависимости от выбора (например, если выбор расы меняет доступные атрибуты).
Общее для обоих файлов:
Использование wp_localize_script для получения AJAX URL, nonces (для безопасности) и других данных из PHP.
Отправка AJAX-запросов к соответствующим обработчикам (Includes\Core\AJAXHandler.php или Includes\Admin\AdminAJAXHandler.php).
Обработка ответов от сервера и обновление DOM.
5. Интеграция с WooCommerce
Этот раздел описывает, как ваша тема расширяет и взаимодействует с плагином WooCommerce.
5.1. includes/WooCommerce/WooCommerceIntegration.php
Назначение: Основной класс для управления всей логикой интеграции с WooCommerce. Он будет регистрировать хуки и фильтры WooCommerce для добавления кастомного поведения.
Вероятные задачи:
Инициализация: Создание экземпляров других классов этого модуля (например, DiscountManager).
Регистрация хуков:
Хуки, связанные с товарами (например, woocommerce_single_product_summary для добавления информации, woocommerce_get_price_html для изменения отображения цены).
Хуки, связанные с корзиной и оформлением заказа (например, woocommerce_cart_calculate_fees для добавления сборов или скидок, woocommerce_before_calculate_totals для изменения цен товаров в корзине, woocommerce_checkout_process для дополнительной валидации, woocommerce_thankyou для действий после оформления заказа).
Хуки, связанные с аккаунтом пользователя (как мы уже видели в CharacterPage.php, но здесь может быть более общая логика).
Хуки для добавления кастомных полей к товарам или заказам.
Взаимодействие с RPG-системой:
Получение данных персонажа для применения скидок или предоставления бонусов.
Начисление опыта персонажу за покупки (woocommerce_order_status_completed хук).
Управление кастомными типами данных WooCommerce: Если создаются кастомные типы купонов, продуктов или таксономий.
5.2. includes/WooCommerce/DiscountManager.php
Назначение: Управляет логикой применения кастомных скидок. Эти скидки могут быть основаны на RPG-атрибутах персонажа, его уровне, расе или других условиях.
Вероятные свойства:
Правила скидок (могут храниться в опциях темы или загружаться из другого источника).
Вероятные методы:
apply_discounts(WC_Cart $cart): Основной метод, который вызывается во время расчета корзины (например, через хук woocommerce_cart_calculate_fees или woocommerce_before_calculate_totals). Этот метод проверяет условия для каждой скидки и применяет ее к корзине или отдельным товарам.
get_character_based_discount(Character $character, WC_Cart $cart): Расчет скидки на основе данных персонажа.
is_discount_applicable(array $discount_rule, Character $character, WC_Cart $cart): Проверка, применима ли конкретная скидка.
add_discount_to_cart(WC_Cart $cart, string $discount_name, float $discount_amount, bool $is_percentage): Добавление скидки в корзину. WooCommerce предоставляет API для добавления скидок (fees).
Примеры логики скидок:
Скидка X% для персонажей уровня Y и выше.
Скидка Z% для персонажей определенной расы на определенные категории товаров.
Фиксированная скидка для персонажей с высоким значением атрибута "Торговля" (если такой есть).
Взаимодействие:
WooCommerceIntegration будет вызывать методы DiscountManager.
DiscountManager будет получать данные о персонаже из класса Character.
5.3. assets/js/rpg-cart.js
Назначение: JavaScript для взаимодействия с RPG-элементами на странице корзины или оформления заказа.
Возможные функции:
Динамическое отображение скидок: Если скидки применяются или изменяются на основе действий пользователя на странице (хотя обычно скидки рассчитываются на стороне сервера).
AJAX-запросы для обновления информации: Например, если выбор опции доставки или способа оплаты влияет на RPG-бонусы.
Отображение сообщений: Информирование пользователя о примененных RPG-скидках или бонусах.
Взаимодействие с Core\AJAXHandler.php или WooCommerceIntegration.php (если там есть AJAX-обработчики).
Пример:
Если у пользователя есть персонаж с определенным перком, который дает бесплатную доставку, этот скрипт может помочь отобразить это сообщение или обновить итоги корзины (хотя основная логика все равно будет на сервере).
Общие паттерны интеграции с WooCommerce:
Использование мета-данных:
Пользователи: RPG-данные хранятся в wp_usermeta.
Товары: Можно добавлять кастомные мета-поля к товарам (например, "Требуемый уровень для покупки", "Дает X опыта при покупке"). Это делается через хуки woocommerce_product_options_general_product_data (для добавления полей в админку товара) и woocommerce_process_product_meta (для сохранения).
Заказы: Можно добавлять мета-данные к заказам и элементам заказа (например, "Применена RPG-скидка", "Начислено опыта").
Хуки для изменения поведения: WooCommerce имеет огромное количество хуков, позволяющих модифицировать практически любой аспект его работы. Ключ к успешной интеграции – найти правильные хуки.
Шаблоны WooCommerce:
Можно переопределять стандартные шаблоны WooCommerce, копируя их из папки плагина woocommerce/templates/ в папку your-theme/woocommerce/. Это позволяет кастомизировать внешний вид страниц магазина, товаров, корзины и т.д., добавляя туда RPG-информацию.
Файл templates/myaccount/character-page-content.php – хороший пример кастомизации страницы "Мой аккаунт".
Потенциальные точки интеграции RPG и WooCommerce:
Доступ к товарам: Ограничение покупки товаров на основе уровня или расы персонажа.
Цены и скидки: Динамическое изменение цен или применение скидок на основе RPG-параметров.
Начисление опыта/валюты: За покупки, за отзывы на товары.
RPG-атрибуты товаров: Товары могут давать временные или постоянные бонусы к атрибутам персонажа.
Квесты, связанные с магазином: "Купи X товаров из категории Y", "Потрать Z сумму".
6. Интеграция с Dokan
Этот раздел посвящен тому, как ваша тема взаимодействует с плагином Dokan для создания многопользовательского маркетплейса с RPG-элементами. Dokan позволяет пользователям (продавцам) создавать свои магазины и продавать товары. Ваша интеграция, вероятно, добавляет кастомные функции для продавцов и, возможно, для покупателей в контексте магазинов продавцов.
6.1. includes/Integration/dokan/DokanIntegrationManager.php
Назначение: Центральный класс для управления всей логикой интеграции с Dokan. По аналогии с WooCommerceIntegration.php, он будет регистрировать хуки и фильтры Dokan.
Вероятные задачи:
Инициализация: Создание экземпляров других классов этого модуля (например, DokanUserCouponDB, DokanAJAXHandler).
Регистрация хуков Dokan:
Хуки, связанные с панелью управления продавца (например, для добавления новых разделов, полей или изменения существующих).
Хуки, связанные с продуктами продавца (например, для добавления RPG-атрибутов к товарам, которые может указать продавец).
Хуки, связанные с купонами продавца (Dokan имеет свою систему купонов для продавцов).
Хуки, связанные с профилем магазина продавца.
Хуки для изменения процесса вывода средств или отчетов.
Взаимодействие с RPG-системой:
Возможно, продавцы могут получать RPG-бонусы или опыт за успешные продажи.
Возможно, есть специальные условия для продавцов в зависимости от их RPG-статуса (если у продавцов тоже есть персонажи/профили).
Управление кастомными функциями для продавцов: Например, расширенное управление купонами, как предполагает наличие DokanUserCouponDB.php и dokan/coupon/store.php.
6.2. includes/Integration/dokan/DokanAJAXHandler.php
Назначение: Обрабатывает AJAX-запросы, специфичные для функционала Dokan, добавленного вашей темой.
Принцип работы:
Регистрирует AJAX-действия WordPress, которые будут вызываться из JavaScript на страницах Dokan (например, из панели управления продавца).
Содержит методы для обработки этих запросов, например, сохранение настроек, создание/обновление кастомных купонов, получение данных.
Взаимодействует с DokanUserCouponDB.php для операций с базой данных.
Возвращает ответы в формате JSON.
Примеры AJAX-действий:
wp_ajax_rpg_dokan_save_vendor_coupon: для сохранения кастомного купона продавца.
wp_ajax_rpg_dokan_get_vendor_settings: для получения каких-либо RPG-настроек продавца.
6.3. includes/Integration/dokan/DokanUserCouponDB.php
Назначение: Этот класс, вероятно, отвечает за взаимодействие с базой данных для хранения и управления кастомными купонами, которые могут создавать продавцы (вендоры Dokan). Стандартные купоны WooCommerce обычно создаются администратором сайта. Эта система, похоже, расширяет возможности Dokan, позволяя продавцам управлять своими собственными, возможно, более гибкими или RPG-связанными купонами.
Вероятные задачи:
Создание/удаление таблицы БД: Если для этих купонов используется отдельная таблица, этот класс может содержать методы для ее создания при активации темы (через Installer.php) и, возможно, удаления.
CRUD-операции:
create_coupon(array $coupon_data): Создание нового купона.
get_coupon(int $coupon_id): Получение данных купона по ID.
get_coupons_by_vendor(int $vendor_id): Получение всех купонов конкретного продавца.
update_coupon(int $coupon_id, array $coupon_data): Обновление данных купона.
delete_coupon(int $coupon_id): Удаление купона.
Валидация данных купона.
Структура таблицы (предположение):
id (PRIMARY KEY)
vendor_id (ID продавца)
coupon_code (код купона)
discount_type (процентный, фиксированный)
discount_amount
description
usage_limit
expiry_date
min_spend
product_ids (для каких товаров действует)
rpg_conditions (возможно, JSON-поле для RPG-условий применения купона, например, "только для эльфов" или "требуется уровень 10+").
6.4. dokan/coupon/store.php
Назначение: Это PHP-шаблон, который переопределяет или добавляет страницу/раздел в панели управления продавца Dokan для управления этими кастомными купонами.
Содержимое:
HTML-разметка для отображения списка купонов продавца.
Формы для создания и редактирования купонов.
Кнопки для удаления купонов.
JavaScript (возможно, инлайн или подключенный отдельно) для AJAX-взаимодействия с DokanAJAXHandler.php для выполнения операций без перезагрузки страницы.
PHP-код для получения данных купонов (вероятно, через DokanUserCouponDB.php) и их вывода.
Переопределение шаблонов Dokan: Dokan, как и WooCommerce, позволяет переопределять свои шаблоны. Этот файл, находящийся в woodmart-child/dokan/coupon/store.php, скорее всего, используется Dokan для отображения соответствующей страницы в личном кабинете продавца. Это стандартный механизм WordPress и многих плагинов для кастомизации фронтенда плагина через тему.
Потенциальные точки интеграции RPG и Dokan:
RPG-условия для купонов продавцов: Продавцы могут создавать купоны, которые активируются только для покупателей с определенными RPG-характеристиками (уровень, раса, атрибут).
RPG-бонусы для продавцов: Продавцы могут получать опыт, уровни или другие RPG-награды за достижение определенных целей продаж, получение хороших отзывов и т.д.
Ограничения для продавцов на основе RPG: Возможно, некоторые функции Dokan (например, возможность продавать определенные категории товаров или использовать продвинутые инструменты) становятся доступны продавцам только после достижения ими определенного RPG-статуса.
Отображение RPG-статуса продавца: На странице магазина продавца может отображаться его RPG-профиль или значки достижений, что может влиять на доверие покупателей.
7. Кастомизация админ-панели
Этот модуль отвечает за изменения в стандартной административной панели WordPress, в основном связанные с управлением пользователями и их RPG-данными.
7.1. includes/Admin/UserProfile.php
Назначение: Добавляет кастомные поля и секции на страницу редактирования профиля пользователя в админ-панели WordPress (wp-admin/profile.php и wp-admin/user-edit.php). Это позволяет администраторам просматривать и редактировать RPG-данные пользователей.
Основные задачи:
Добавление полей: Использование хуков show_user_profile (для страницы своего профиля) и edit_user_profile (для страницы редактирования чужого профиля) для вывода HTML-полей.
Поля для отображения/редактирования имени персонажа.
Выпадающий список или радио-кнопки для выбора/изменения расы персонажа (вероятно, с использованием RaceFactory для получения списка доступных рас).
Поле для ввода уровня персонажа.
Поле для ввода очков опыта (XP).
Поля для редактирования атрибутов персонажа (сила, ловкость и т.д.).
Возможно, отображение инвентаря или других RPG-специфичных данных.
Сохранение полей: Использование хуков personal_options_update (для своего профиля) и edit_user_profile_update (для чужого профиля) для сохранения значений этих кастомных полей.
Валидация и очистка (sanitization) вводимых данных перед сохранением.
Использование функций update_user_meta() для сохранения данных в wp_usermeta.
Взаимодействие с классом Character: При загрузке и сохранении данных, вероятно, происходит взаимодействие с методами класса Character для обеспечения консистентности данных.
Пример добавления поля:
// В классе UserProfile
public function display_rpg_fields_on_profile($user) {
    // $user - это объект WP_User
    $character = new \Includes\RPG\Character($user->ID);
    ?>
    <h3><?php _e('RPG Характеристики Персонажа', 'your-text-domain'); ?></h3>
    <table class="form-table">
        <tr>
            <th><label for="rpg_character_name"><?php _e('Имя персонажа', 'your-text-domain'); ?></label></th>
            <td>
                <input type="text" name="rpg_character_name" id="rpg_character_name" value="<?php echo esc_attr($character->get_name()); ?>" class="regular-text" />
            </td>
        </tr>
        <tr>
            <th><label for="rpg_character_level"><?php _e('Уровень', 'your-text-domain'); ?></label></th>
            <td>
                <input type="number" name="rpg_character_level" id="rpg_character_level" value="<?php echo esc_attr($character->get_level()); ?>" class="small-text" />
            </td>
        </tr>
        <?php // Другие поля: раса, опыт, атрибуты ?>
    </table>
    <?php
}

public function save_rpg_fields_on_profile($user_id) {
    if (!current_user_can('edit_user', $user_id)) {
        return false;
    }
    // Сохранение имени персонажа
    if (isset($_POST['rpg_character_name'])) {
        update_user_meta($user_id, 'rpg_character_name', sanitize_text_field($_POST['rpg_character_name']));
    }
    // Сохранение уровня
    if (isset($_POST['rpg_character_level'])) {
        update_user_meta($user_id, 'rpg_character_level', intval($_POST['rpg_character_level']));
    }
    // Сохранение других полей
    // Возможно, обновление объекта Character и вызов $character->save_character_data();
}


7.2. includes/Admin/UserTable.php
Назначение: Добавляет кастомные колонки в таблицу пользователей WordPress (wp-admin/users.php) для отображения ключевой RPG-информации. Это позволяет администраторам быстро просматривать RPG-статус пользователей.
Основные задачи:
Добавление колонок: Использование фильтра manage_users_columns для добавления новых заголовков колонок (например, "Раса", "Уровень").
Отображение данных в колонках: Использование фильтра manage_users_custom_column для вывода значений в этих новых колонках для каждого пользователя.
Получение RPG-данных пользователя (раса, уровень и т.д.) с помощью get_user_meta() или через объект Character.
Возможность сортировки колонок: Использование фильтра manage_users_sortable_columns для объявления колонок сортируемыми и хука pre_get_users для изменения WP_User_Query при сортировке по кастомным колонкам (обычно сортировка по мета-полям).
Пример добавления колонки:
// В классе UserTable
public function add_rpg_user_table_columns($columns) {
    $columns['rpg_race'] = __('Раса', 'your-text-domain');
    $columns['rpg_level'] = __('Уровень', 'your-text-domain');
    return $columns;
}

public function display_rpg_user_table_columns_data($value, $column_name, $user_id) {
    $character = new \Includes\RPG\Character($user_id);
    if ('rpg_race' === $column_name) {
        $race = $character->get_race();
        return $race ? esc_html($race->get_name()) : 'N/A';
    }
    if ('rpg_level' === $column_name) {
        return esc_html($character->get_level());
    }
    return $value;
}


7.3. includes/Admin/AdminAJAXHandler.php
Назначение: Обрабатывает AJAX-запросы, инициированные из административной части сайта, связанные с RPG-функционалом.
Принцип работы:
Регистрирует AJAX-действия WordPress (wp_ajax_your_admin_action). Поскольку это админ-панель, wp_ajax_nopriv_ обычно не используется.
Содержит методы для выполнения специфических административных задач, таких как:
Массовое обновление RPG-данных пользователей.
Поиск пользователей по RPG-критериям.
Любые другие интерактивные действия на кастомных страницах админ-панели, связанные с RPG.
Взаимодействует с классами Character, LevelManager, RaceFactory и другими для манипуляции данными.
Возвращает ответы в формате JSON.
Взаимодействие с assets/js/rpg-admin-profile.js: Этот JS-файл, вероятно, отправляет AJAX-запросы на действия, зарегистрированные в AdminAJAXHandler.php, например, при изменении RPG-данных в профиле пользователя для сохранения без полной перезагрузки страницы или для динамической подгрузки информации.
Общие цели кастомизации админ-панели:
Удобство управления: Предоставить администраторам удобные инструменты для управления RPG-аспектами пользователей.
Обзор данных: Дать возможность быстро оценить состояние RPG-системы (например, сколько персонажей какой расы, средний уровень и т.д., если добавляются кастомные дашборды).
Модерация: Возможность вручную корректировать RPG-данные пользователей при необходимости.
8. Шорткоды (includes/Shortcodes/)
Шорткоды в WordPress – это мощный инструмент для вставки динамического контента в посты, страницы и виджеты без необходимости писать PHP-код напрямую в редакторе. Ваша тема использует их для вывода кастомных элементов, связанных с RPG-системой.
8.1. includes/Shortcodes/RegisterFormShortcode.php
Назначение: Этот класс регистрирует и обрабатывает шорткод (например, [rpg_register_form]) для вывода кастомной формы регистрации. Стандартная форма регистрации WordPress может быть недостаточно гибкой для ваших нужд, особенно если вы хотите сразу при регистрации собирать RPG-специфичные данные (например, выбор расы, имя персонажа).
Основные задачи:
Регистрация шорткода: Использование функции add_shortcode('your_shortcode_tag', [$this, 'render_shortcode_callback']) в конструкторе класса или при инициализации.
Метод рендеринга (render_shortcode_callback):
Генерирует HTML-разметку для формы регистрации. Это может включать стандартные поля (имя пользователя, email, пароль) и кастомные поля (выбор расы, имя персонажа, выбор гендера – возможно, с использованием другого шорткода [gender_select]).
Может включать скрытые поля, nonces для безопасности.
Может загружать отдельный шаблонный файл для HTML-разметки формы, чтобы отделить логику от представления.
Обработка отправки формы:
Этот класс может также содержать логику для обработки данных, отправленных через эту форму. Это часто делается путем проверки $_POST данных на хуке init или template_redirect, если форма отправляется на ту же страницу.
Валидация введенных данных.
Создание нового пользователя WordPress с помощью wp_create_user() или wp_insert_user().
Сохранение дополнительных RPG-данных (раса, имя персонажа, гендер) в мета-поля пользователя (update_user_meta()).
Возможно, автоматический вход пользователя после успешной регистрации (wp_signon()).
Обработка ошибок и вывод сообщений пользователю.
Взаимодействие:
Может использовать RaceFactory для получения списка рас для выбора.
Может взаимодействовать с Character::save_character_data() или напрямую с update_user_meta() для сохранения RPG-данных.
JavaScript (assets/js/login-register.js) может использоваться для клиентской валидации формы и/или AJAX-отправки.
8.2. includes/Shortcodes/GenderSelectShortcode.php
Назначение: Регистрирует и обрабатывает шорткод (например, [rpg_gender_select]) для вывода поля выбора гендера. Этот шорткод может использоваться как часть кастомной формы регистрации или на странице профиля персонажа.
Основные задачи:
Регистрация шорткода: Аналогично RegisterFormShortcode.
Метод рендеринга:
Генерирует HTML для поля выбора гендера (например, выпадающий список <select> или радио-кнопки <input type="radio">).
Варианты гендеров могут быть жестко закодированы или браться из настроек темы.
Атрибуты шорткода: Может принимать атрибуты для кастомизации, например, [rpg_gender_select default="male" display="dropdown"].
Использование:
Может быть встроен в вывод шорткода [rpg_register_form].
Может использоваться отдельно на странице редактирования профиля персонажа.
Общий механизм работы шорткодов:
Класс шорткода регистрируется (обычно на хуке init).
Когда WordPress встречает тег шорткода в контенте, он вызывает соответствующую callback-функцию.
Callback-функция генерирует HTML-код и возвращает его. Этот HTML затем вставляется на место тега шорткода.
Шорткоды предоставляют гибкий способ добавления сложной функциональности в контент без необходимости для пользователя знать HTML или PHP.
9. Ассеты (CSS/JS) (assets/)
Эта директория содержит статические файлы – каскадные таблицы стилей (CSS) и JavaScript-файлы, которые отвечают за внешний вид и интерактивность кастомных элементов вашей темы. Управление их подключением, как мы уже упоминали, скорее всего, осуществляется классом includes/Assets/AssetManager.php.
9.1. includes/Assets/AssetManager.php (Повторение и детализация)
Назначение: Централизованное управление регистрацией и подключением всех CSS и JS файлов темы.
Ключевые методы и хуки:
__construct(): Обычно здесь добавляются хуки wp_enqueue_scripts (для фронтенда) и admin_enqueue_scripts (для админ-панели).
enqueue_frontend_assets() (или аналогичный метод, вызываемый хуком wp_enqueue_scripts):
Регистрирует (wp_register_style, wp_register_script) и подключает (wp_enqueue_style, wp_enqueue_script) CSS и JS файлы, необходимые для фронтенда.
Использует условные теги WordPress (например, is_page(), is_singular(), is_woocommerce(), is_account_page()) для подключения ассетов только на тех страницах, где они действительно нужны. Это оптимизирует загрузку сайта.
Задает зависимости для скриптов (например, jQuery или другие библиотеки).
Указывает версию файла (для корректного кеширования браузером).
Может подключать скрипты в футере ($in_footer = true в wp_enqueue_script).
enqueue_admin_assets() (или аналогичный, для хука admin_enqueue_scripts):
Подключает CSS и JS, необходимые для кастомизации админ-панели (например, для стилизации полей в профиле пользователя или для JS-логики на кастомных страницах админки).
Хук admin_enqueue_scripts передает параметр $hook_suffix, который можно использовать для точного определения текущей страницы админ-панели и подключения скриптов только там.
localize_scripts(): Использует wp_localize_script() для передачи данных из PHP в JavaScript. Это критически важно для AJAX-запросов (передача admin_ajax_url, nonces для безопасности), а также для передачи любых других настроек или переведенных строк.
Пример:
wp_localize_script('rpg-cart-js', 'rpgCartData', [
    'ajax_url' => admin_url('admin-ajax.php'),
    'nonce'    => wp_create_nonce('rpg_cart_nonce'),
    'cart_total_message' => __('Ваша RPG скидка применена!', 'your-text-domain')
]);

В JavaScript эти данные будут доступны через объект rpgCartData.
9.2. CSS Файлы
assets/css/login-register.css:
Назначение: Стилизует кастомную форму регистрации и, возможно, страницу входа, если она также кастомизирована.
Содержимое: CSS-правила для оформления полей ввода, кнопок, сообщений об ошибках, общей компоновки формы.
Подключение: Вероятно, подключается через AssetManager на страницах, где используется шорткод [rpg_register_form] или на стандартных страницах входа/регистрации WordPress, если они переопределены.
style.css (woodmart-child/style.css):
Назначение: Основной файл стилей дочерней темы.
Содержимое:
Заголовок темы: Обязательный блок комментариев с информацией о теме (имя темы, URI, автор, версия, шаблон родительской темы – Template: woodmart).
Кастомные стили: Общие стили для всей темы, переопределения стилей родительской темы WoodMart, стили для RPG-элементов, не покрытых другими специфическими CSS-файлами.
Подключение: WordPress автоматически подключает style.css дочерней темы. AssetManager может также его подключать или управлять его зависимостями.
9.3. JavaScript Файлы
assets/js/login-register.js:
Назначение: Обеспечивает интерактивность для кастомной формы регистрации/входа.
Возможные функции:
Клиентская валидация полей: Проверка корректности введенных данных (например, формат email, сложность пароля) перед отправкой на сервер.
AJAX-отправка формы: Отправка данных формы на сервер без перезагрузки страницы. Обработка ответа от сервера (успех/ошибка) и отображение сообщений пользователю.
Манипуляции с DOM для улучшения пользовательского опыта (например, показ/скрытие полей, индикаторы загрузки).
Взаимодействие: С Core\AJAXHandler.php (для обработки регистрации/входа) и с HTML-разметкой, генерируемой RegisterFormShortcode.php.
assets/js/rpg-account.js:
Назначение: Управляет интерактивными элементами на странице персонажа в разделе "Мой аккаунт".
Возможные функции:
AJAX-запросы для обновления данных персонажа (например, смена имени, распределение очков атрибутов при повышении уровня).
Динамическое обновление информации на странице без перезагрузки.
Обработка пользовательского ввода для интерактивных RPG-элементов.
Взаимодействие: С Core\AJAXHandler.php (или специфичным обработчиком для аккаунта) и с HTML-разметкой из templates/myaccount/character-page-content.php.
assets/js/rpg-admin-profile.js:
Назначение: Добавляет интерактивность на страницу редактирования профиля пользователя в админ-панели WordPress, где отображаются RPG-поля.
Возможные функции:
AJAX-сохранение RPG-данных при их изменении администратором.
Динамическая подгрузка или изменение полей в зависимости от выбора (например, если выбор расы влияет на доступные для редактирования атрибуты).
Валидация вводимых администратором данных.
Взаимодействие: С Admin\AdminAJAXHandler.php и с HTML-полями, добавленными Admin\UserProfile.php.
assets/js/rpg-cart.js:
Назначение: Логика JavaScript для страницы корзины, связанная с RPG-элементами.
Возможные функции:
Отображение уведомлений о RPG-скидках или бонусах.
Возможно, AJAX-запросы для пересчета корзины, если какие-то RPG-условия меняются динамически на стороне клиента (хотя обычно это делается на сервере).
Обновление элементов DOM на странице корзины для отражения RPG-информации.
Взаимодействие: С Core\AJAXHandler.php или WooCommerceIntegration.php (если там есть AJAX-обработчики для корзины) и с HTML-элементами на странице корзины WooCommerce.
Общие принципы работы с ассетами:
Минификация: Для продакшн-сайта CSS и JS файлы следует минифицировать для уменьшения их размера и ускорения загрузки.
Конкатенация: Объединение нескольких CSS или JS файлов в один также может улучшить производительность.
Условная загрузка: Загружать ассеты только там, где они нужны, – ключевой принцип оптимизации.
Зависимости: Правильно указывать зависимости для скриптов (например, если ваш скрипт использует jQuery, jQuery должен быть загружен раньше).
10. Ключевые рабочие процессы и взаимодействия
Этот раздел объединяет ранее проанализированные компоненты для описания полных пользовательских сценариев. Особое внимание уделено процессам, связанным с купонами.
10.1. Рабочие процессы, связанные с купонами
Поскольку система купонов часто бывает сложной, рассмотрим ее подробно. У вас есть два основных типа скидок/купонов:
Кастомные купоны продавцов (Dokan): Управляются продавцами через их панель.
Общие RPG-скидки (WooCommerce): Применяются автоматически на основе RPG-статуса покупателя.
10.1.1. Сценарий: Создание кастомного купона продавцом (Dokan)
Вход и навигация:
Продавец (пользователь с ролью seller или аналогичной, управляемой Dokan) входит в систему.
Переходит в свою панель управления Dokan (обычно /dashboard/coupons/ или похожий URL).
Задействованные файлы/классы: Стандартная система входа WordPress, маршрутизация Dokan.
Отображение интерфейса управления купонами:
Dokan загружает шаблон для управления купонами. Если вы его переопределили, то это woodmart-child/dokan/coupon/store.php.
Этот шаблон отображает форму для создания нового купона и список существующих купонов продавца.
Данные для списка существующих купонов, вероятно, извлекаются с помощью методов класса Includes\Integration\dokan\DokanUserCouponDB.php (например, get_coupons_by_vendor(dokan_get_current_user_id())).
Задействованные файлы/классы: dokan/coupon/store.php, Includes\Integration\dokan\DokanUserCouponDB.php.
Заполнение и отправка формы создания/редактирования купона:
Продавец заполняет поля формы: код купона, тип скидки, сумма, ограничения (дата окончания, минимальная сумма заказа, товары, лимит использования) и, важно, любые кастомные RPG-условия (например, "только для расы Эльф", "требуется уровень 10+").
При отправке формы, JavaScript (встроенный в store.php или подключенный отдельно, возможно, с использованием данных из wp_localize_script от AssetManager) может выполнить клиентскую валидацию.
Данные формы отправляются на сервер, скорее всего, через AJAX-запрос.
Задействованные файлы/классы: dokan/coupon/store.php (HTML-форма, JS), includes/Assets/AssetManager.php (для wp_localize_script с AJAX URL и nonce).
Обработка AJAX-запроса на сервере:
AJAX-запрос поступает на admin-ajax.php WordPress и направляется в соответствующий метод класса Includes\Integration\dokan\DokanAJAXHandler.php (например, handle_save_vendor_coupon).
Безопасность: Первым делом проверяется nonce, переданный с запросом, и права пользователя (что это действительно продавец и он может управлять своими купонами).
Валидация данных: Данные из $_POST (или $_REQUEST) валидируются и очищаются (sanitized).
Задействованные файлы/классы: Includes\Integration\dokan\DokanAJAXHandler.php.
Сохранение данных купона в БД:
DokanAJAXHandler.php вызывает метод класса Includes\Integration\dokan\DokanUserCouponDB.php (например, create_coupon() или update_coupon()) для сохранения данных.
Этот метод формирует SQL-запрос (или использует $wpdb) для вставки/обновления записи в кастомной таблице купонов. Особое внимание уделяется сохранению поля rpg_conditions (возможно, как сериализованный массив или JSON).
Задействованные файлы/классы: Includes\Integration\dokan\DokanUserCouponDB.php.
Ответ клиенту и обновление интерфейса:
DokanAJAXHandler.php возвращает JSON-ответ (wp_send_json_success() или wp_send_json_error()) обратно в JavaScript.
JavaScript на стороне клиента обрабатывает ответ:
В случае успеха: обновляет список купонов на странице dokan/coupon/store.php (добавляет новый/обновляет существующий), очищает форму, показывает сообщение об успехе.
В случае ошибки: показывает сообщение об ошибке.
Задействованные файлы/классы: dokan/coupon/store.php (JS), Includes\Integration\dokan\DokanAJAXHandler.php.
Потенциальные проблемы в этом сценарии:
Неправильная nonce-проверка или ее отсутствие.
Недостаточная валидация и очистка данных перед сохранением в БД (риск SQL-инъекций или XSS).
Ошибки в SQL-запросах в DokanUserCouponDB.php.
Некорректная обработка AJAX-запросов или ответов (JS-ошибки).
Проблемы с правами доступа (продавец не может сохранить купон).
Неправильное сохранение/чтение RPG-условий.
10.1.2. Сценарий: Применение купона продавца покупателем
Добавление товаров и ввод купона:
Покупатель добавляет товары в корзину (товары могут быть от разных продавцов).
На странице корзины или оформления заказа WooCommerce покупатель вводит код купона (созданного продавцом) в стандартное поле WooCommerce.
Задействованные файлы/классы: Шаблоны корзины/оформления заказа WooCommerce.
Стандартная обработка купона WooCommerce:
WooCommerce перехватывает отправку формы с кодом купона.
Сначала он пытается найти купон среди стандартных купонов WooCommerce (тип поста shop_coupon).
Кастомная логика проверки и применения купона продавца:
Здесь ваша тема должна вмешаться. Это может быть реализовано через несколько хуков:
Хук woocommerce_coupon_is_valid (фильтр): Вы можете использовать этот фильтр, чтобы проверить, является ли введенный код купоном из вашей кастомной таблицы DokanUserCouponDB.
В функции-обработчике этого фильтра:
Получите объект купона WooCommerce ($coupon).
Попытайтесь найти купон с таким же кодом в вашей кастомной таблице через DokanUserCouponDB->get_coupon_by_code($coupon->get_code()).
Если найден кастомный купон продавца:
Проверьте его условия: срок действия, лимиты использования, минимальную сумму заказа.
Важно: Проверьте, есть ли в корзине товары от продавца, которому принадлежит этот купон. Если нет, купон недействителен для текущей корзины.
RPG-условия: Если у купона есть rpg_conditions:
Получите объект текущего персонажа покупателя: new \Includes\RPG\Character(get_current_user_id()).
Сравните данные персонажа (уровень, раса, атрибуты) с rpg_conditions. Если не соответствует, купон недействителен.
Если все проверки пройдены, верните true. Иначе, можно выбросить исключение с сообщением об ошибке, которое увидит пользователь (например, throw new \Exception(__('Этот купон недействителен для вашего персонажа.', 'your-text-domain'));).
Хук woocommerce_cart_calculate_fees (действие) или woocommerce_before_calculate_totals (действие): Если вы не используете стандартный механизм купонов WooCommerce для скидок от продавцов, а применяете их как кастомные скидки/сборы.
В функции-обработчике:
Проверьте, был ли введен код купона (возможно, сохраненный в сессии WC).
Если да, извлеките данные купона из DokanUserCouponDB.
Выполните все проверки (принадлежность продавцу, RPG-условия и т.д.), как описано выше.
Если купон валиден, примените скидку с помощью WC()->cart->add_fee('Скидка от продавца X', -$discount_amount);.
Задействованные файлы/классы: Includes\Integration\dokan\DokanIntegrationManager.php (вероятно, здесь будут хуки), Includes\Integration\dokan\DokanUserCouponDB.php, Includes\RPG\Character.php.
Отображение результата:
WooCommerce обновит итоги корзины, отобразив примененную скидку или сообщение об ошибке, если купон недействителен.
assets/js/rpg-cart.js может использоваться для дополнительного информирования пользователя (например, кастомные уведомления о RPG-условиях).
Задействованные файлы/классы: Шаблоны WooCommerce, assets/js/rpg-cart.js.
Потенциальные проблемы в этом сценарии:
Конфликты между стандартными купонами WooCommerce и кастомными купонами продавцов.
Неправильная логика проверки принадлежности купона продавцу товаров в корзине.
Ошибки в проверке RPG-условий.
Некорректное применение скидки (например, скидка применяется ко всем товарам, а не только к товарам конкретного продавца, если это требуется).
Проблемы с отображением сообщений об ошибках или статусе купона.
10.1.3. Сценарий: Автоматическое применение общей RPG-скидки (WooCommerce)
Этот сценарий не связан с вводом кода купона, а скорее с автоматическими скидками на основе RPG-статуса пользователя.
Расчет итогов корзины:
Пользователь находится на странице корзины или оформления заказа. WooCommerce начинает рассчитывать итоги.
Задействованные файлы/классы: Ядро WooCommerce.
Срабатывание хука для применения скидок:
Ваша тема использует хук, такой как woocommerce_cart_calculate_fees или woocommerce_before_calculate_totals. Этот хук зарегистрирован в Includes\WooCommerce\WooCommerceIntegration.php.
Задействованные файлы/классы: Includes\WooCommerce\WooCommerceIntegration.php.
Логика менеджера скидок:
Функция-обработчик хука вызывает метод из Includes\WooCommerce\DiscountManager.php (например, apply_discounts(WC()->cart)).
Внутри DiscountManager:
Получается ID текущего пользователя: get_current_user_id().
Если пользователь авторизован, создается объект персонажа: $character = new \Includes\RPG\Character($user_id);.
Если персонаж существует ($character->has_character()), менеджер проверяет определенные правила скидок (эти правила могут быть заданы в админ-панели WordPress, в настройках темы, или жестко закодированы).
Для каждого правила скидки проверяется, применимо ли оно (is_discount_applicable()):
Сравниваются данные персонажа (уровень, раса, атрибуты, возможно, предметы в инвентаре) с условиями правила.
Могут также проверяться условия корзины (например, общая сумма, наличие определенных товаров или категорий).
Если правило применимо, рассчитывается сумма скидки и она добавляется в корзину через add_discount_to_cart(), который, в свою очередь, использует WC()->cart->add_fee('RPG Скидка: Воин Уровня 10', -$discount_amount);.
Задействованные файлы/классы: Includes\WooCommerce\DiscountManager.php, Includes\RPG\Character.php.
Отображение скидки:
Примененная RPG-скидка отображается в итогах корзины как отдельная строка.
assets/js/rpg-cart.js может выводить дополнительные уведомления или пояснения по поводу примененной скидки.
Задействованные файлы/классы: Шаблоны WooCommerce, assets/js/rpg-cart.js.
Потенциальные проблемы в этом сценарии:
Неправильно определены или настроены правила скидок.
Ошибки в логике проверки условий применимости скидки в DiscountManager.php.
Конфликты, если несколько RPG-скидок могут быть применены одновременно (нужна логика приоритетов или суммирования).
Скидки применяются некорректно или не к тем товарам/суммам.
10.2. Другие ключевые рабочие процессы (кратко)
Регистрация пользователя и создание персонажа:
Пользователь заполняет форму (шорткод [rpg_register_form]).
assets/js/login-register.js выполняет клиентскую валидацию/AJAX.
Includes\Shortcodes\RegisterFormShortcode.php обрабатывает данные на сервере (возможно, через Core\AJAXHandler.php).
Создается пользователь WordPress (wp_create_user).
Сохраняются мета-данные пользователя (выбранная раса, гендер, имя персонажа).
Создается объект Includes\RPG\Character и инициализируются его базовые атрибуты на основе расы (через RaceFactory и apply_racial_modifiers).
Устанавливается начальный уровень и опыт через LevelManager.
Данные персонажа сохраняются ($character->save_character_data()).
Повышение уровня персонажа:
Персонаж получает опыт (например, за покупку - хук woocommerce_order_status_completed в WooCommerceIntegration.php вызывает Character->add_experience()).
Character->add_experience() вызывает LevelManager->add_experience().
LevelManager->check_for_level_up() проверяет, достаточно ли опыта.
Если да, LevelManager->level_up() увеличивает уровень, возможно, атрибуты, сохраняет данные персонажа.
Пользователь видит обновленную информацию на странице персонажа (templates/myaccount/character-page-content.php).
Я постарался максимально подробно описать процессы, связанные с купонами. Надеюсь, это поможет вам выявить проблемные места. Если какой-то конкретный шаг или файл вызывает у вас вопросы или вы видите несоответствие с тем, как это должно работать, дайте знать, и мы углубимся еще больше.
